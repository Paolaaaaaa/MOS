# -*- coding: utf-8 -*-
"""Parcial2ej3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QRXMrQrBYZ2u7LDQcHbGdp3mx8dfvS-C
"""

from scipy.optimize import fsolve

# Restricciones y funciones objetivo
def objFunc(X):
    return 2*X[0]-4*X[1]


def restriccion0(X):
    return 2*X[0]+X[1]-100


def restriccion1(X):
    return X[0]+X[1]-80



def restriccion2(X):
    return X[0]-40

def restriccion3(X):
    return X[0]
def restriccion4(X):
    return X[1]

restricciones = [objFunc, restriccion0, restriccion1, restriccion2, restriccion3, restriccion4]

# Puntos Intercepción

initial_guess = [0,0]
puntos_criticos = []


restriction_m0 =[restriccion0, restriccion1, restriccion2]
restriction_m1 =[restriccion3, restriccion4]

#Verificar que está en la región factible
def verify_restr(X):
    for i in range(0,len(restriction_m0)):

        if restriction_m0[i](X)> 0:
          return -1
    for i in range(0,len(restriction_m1)):

        if restriction_m1[i](X)<0:
          return -1
    return X

# Encontrar puntos de intercepción y añadar a la lista de puntos criticos
for i in range(len(restricciones)):
    _por_restriccion = []
    for j in range(len(restricciones)):
       if (i!=j):
            def combined_constraints(X):
                return [restricciones[i](X), restricciones[j](X)]

            intersection_point = fsolve(combined_constraints, [0, 0])
            X_test = [round(intersection_point[0]), round(intersection_point[1])]
            if verify_restr(X_test)!= -1 and (X_test not in puntos_criticos):
              puntos_criticos.append(X_test)
              _por_restriccion.append(X_test)
print("Puntos de intercepción:")
print(puntos_criticos)

import matplotlib.pyplot as plt
import numpy as np
from scipy.spatial import ConvexHull, convex_hull_plot_2d # para encontrar el polinomio

hull = ConvexHull(puntos_criticos)
# para encontrar el camino para formar la forma convexa
points_ = hull.points
order = hull.vertices

# Ordena los puntos en base al camino del polinomio
order_points=[]
for i in order:
  order_points.append(points_[i])
print("Puntos en orden:")
print(order_points)

# Implementación algorithmo simplex


def simplex (point_inic,fevs):

    found = False
    x, y = point_inic
    for i in range(len(fevs)):
      if fevs[i][0]==x and fevs[i][1]==y:
        indice_ = i

    #calculo del punto inicial en la función objetivo
    adj_0_of=objFunc([fevs[i][0],fevs[i][1]])
    while (not found ) :

        # punto adjacente a la izquierda
        if indice_+1==len(fevs):
            adj_1 = fevs[0]
        else:
            adj_1 = fevs[indice_+1]

        # punto adjacente a la derecha
        adj_2= fevs[indice_-1]

        #calculo en la función objetivo para adj: izquierda
        adj_1_of=objFunc([adj_1[0],adj_1[1]])
        #calculo en la función objetivo para adj: derecha

        adj_2_of=objFunc([adj_2[0],adj_2[1]])

        # cuando adj iz y adj derecha son peores se retorna el punto actual
        if(adj_0_of>=adj_1_of and adj_0_of>=adj_2_of):
          found= True
          return {"Punto Optimo":adj_0_of, "Punto": fevs[indice_]}
       # cuando adj iz es mejor que el actual, se actualiza el punto

        elif(adj_1_of>adj_0_of):
          adj_0_of=adj_1_of
          if indice_+1==len(fevs):
              indice_ = 0
          else:
              indice_ = indice_+1
        # cuando adj derecha es mejor que el actual, se actualiza el punto a revisar

        elif(adj_2_of>adj_0_of):
           adj_0_of=adj_2_of
           indice_=indice_-1

punto_optimo=simplex([20,60], order_points)
print("######################################")
print("######################################")
print("######################################")
print("######################################")
print(" Apliación de Algorithmo simplex:")
print("-------------------------------------")
print("Punto optimo encontrado:")
print(punto_optimo)
